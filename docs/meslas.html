

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>meslas package &mdash; MESLAS 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link href="_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> MESLAS
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="philosophy.html">Notations and Conventions for the MESLAS package</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Main Modules:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="grid.html">Gridding Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="random_fields.html">Gaussian Random Field Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="sensor.html">Sensor Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="means.html">Means module</a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html">Plotting module</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MESLAS</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>meslas package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/meslas.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="meslas-package">
<h1>meslas package<a class="headerlink" href="#meslas-package" title="Permalink to this heading">¶</a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="meslas.covariance.html">meslas.covariance package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="meslas.covariance.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="meslas.covariance.html#module-meslas.covariance.cross_covariances">meslas.covariance.cross_covariances module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.cross_covariances.LinearTrendCrossCov"><code class="docutils literal notranslate"><span class="pre">LinearTrendCrossCov</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.cross_covariances.ParabolicTrendCrossCov"><code class="docutils literal notranslate"><span class="pre">ParabolicTrendCrossCov</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.cross_covariances.UniformMixing"><code class="docutils literal notranslate"><span class="pre">UniformMixing</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="meslas.covariance.html#module-meslas.covariance.heterotopic">meslas.covariance.heterotopic module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#conventions">Conventions</a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.heterotopic.FactorCovariance"><code class="docutils literal notranslate"><span class="pre">FactorCovariance</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.heterotopic.FactorCovariance.K"><code class="docutils literal notranslate"><span class="pre">FactorCovariance.K()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.heterotopic.FactorStationaryCovariance"><code class="docutils literal notranslate"><span class="pre">FactorStationaryCovariance</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.heterotopic.StationaryCovariance"><code class="docutils literal notranslate"><span class="pre">StationaryCovariance</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.heterotopic.StationaryCovariance.K"><code class="docutils literal notranslate"><span class="pre">StationaryCovariance.K()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="meslas.covariance.html#module-meslas.covariance.old">meslas.covariance.old module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.old.K_isotopic"><code class="docutils literal notranslate"><span class="pre">K_isotopic()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.old.k"><code class="docutils literal notranslate"><span class="pre">k()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.old.mu"><code class="docutils literal notranslate"><span class="pre">mu()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.old.sample"><code class="docutils literal notranslate"><span class="pre">sample()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.old.sample_isotopic"><code class="docutils literal notranslate"><span class="pre">sample_isotopic()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="meslas.covariance.html#module-meslas.covariance.spatial_covariance_functions">meslas.covariance.spatial_covariance_functions module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="meslas.covariance.html#meslas.covariance.spatial_covariance_functions.Matern32"><code class="docutils literal notranslate"><span class="pre">Matern32()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="meslas.covariance.html#module-meslas.covariance">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="meslas.external_dependencies.html">meslas.external_dependencies package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="meslas.external_dependencies.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="meslas.external_dependencies.html#module-meslas.external_dependencies.numpytorch">meslas.external_dependencies.numpytorch module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch"><code class="docutils literal notranslate"><span class="pre">WrapTorch</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.abs"><code class="docutils literal notranslate"><span class="pre">WrapTorch.abs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.arange"><code class="docutils literal notranslate"><span class="pre">WrapTorch.arange()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.argmax"><code class="docutils literal notranslate"><span class="pre">WrapTorch.argmax()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.argmin"><code class="docutils literal notranslate"><span class="pre">WrapTorch.argmin()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.array"><code class="docutils literal notranslate"><span class="pre">WrapTorch.array()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.backend"><code class="docutils literal notranslate"><span class="pre">WrapTorch.backend</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.cat"><code class="docutils literal notranslate"><span class="pre">WrapTorch.cat()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.exp"><code class="docutils literal notranslate"><span class="pre">WrapTorch.exp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.log"><code class="docutils literal notranslate"><span class="pre">WrapTorch.log()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.max"><code class="docutils literal notranslate"><span class="pre">WrapTorch.max()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.min"><code class="docutils literal notranslate"><span class="pre">WrapTorch.min()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.newaxis"><code class="docutils literal notranslate"><span class="pre">WrapTorch.newaxis</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.ones"><code class="docutils literal notranslate"><span class="pre">WrapTorch.ones()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.sum"><code class="docutils literal notranslate"><span class="pre">WrapTorch.sum()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.sumto1"><code class="docutils literal notranslate"><span class="pre">WrapTorch.sumto1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.WrapTorch.zeros"><code class="docutils literal notranslate"><span class="pre">WrapTorch.zeros()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.aggregate"><code class="docutils literal notranslate"><span class="pre">aggregate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.append_dim"><code class="docutils literal notranslate"><span class="pre">append_dim()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.append_to_ndim"><code class="docutils literal notranslate"><span class="pre">append_to_ndim()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.attach_dim"><code class="docutils literal notranslate"><span class="pre">attach_dim()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.block_diag"><code class="docutils literal notranslate"><span class="pre">block_diag()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.block_diag_irregular"><code class="docutils literal notranslate"><span class="pre">block_diag_irregular()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.bootstrap"><code class="docutils literal notranslate"><span class="pre">bootstrap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.categrnd"><code class="docutils literal notranslate"><span class="pre">categrnd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.circdiff"><code class="docutils literal notranslate"><span class="pre">circdiff()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.conv_t"><code class="docutils literal notranslate"><span class="pre">conv_t()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.crossvalincl"><code class="docutils literal notranslate"><span class="pre">crossvalincl()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.deg2rad"><code class="docutils literal notranslate"><span class="pre">deg2rad()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.delta"><code class="docutils literal notranslate"><span class="pre">delta()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.enforce_tensor"><code class="docutils literal notranslate"><span class="pre">enforce_tensor()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.entropy"><code class="docutils literal notranslate"><span class="pre">entropy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.expand_all"><code class="docutils literal notranslate"><span class="pre">expand_all()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.expand_batch"><code class="docutils literal notranslate"><span class="pre">expand_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.expand_upto_dim"><code class="docutils literal notranslate"><span class="pre">expand_upto_dim()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.float"><code class="docutils literal notranslate"><span class="pre">float()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.freeze"><code class="docutils literal notranslate"><span class="pre">freeze()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.get_jacobian"><code class="docutils literal notranslate"><span class="pre">get_jacobian()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.interp1d"><code class="docutils literal notranslate"><span class="pre">interp1d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.inv_gaussian_cdf"><code class="docutils literal notranslate"><span class="pre">inv_gaussian_cdf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.inv_gaussian_mean_std2params"><code class="docutils literal notranslate"><span class="pre">inv_gaussian_mean_std2params()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.inv_gaussian_pdf"><code class="docutils literal notranslate"><span class="pre">inv_gaussian_pdf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.inv_gaussian_pmf_mean_stdev"><code class="docutils literal notranslate"><span class="pre">inv_gaussian_pmf_mean_stdev()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.inv_gaussian_variance"><code class="docutils literal notranslate"><span class="pre">inv_gaussian_variance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.inv_gaussian_variance2lam"><code class="docutils literal notranslate"><span class="pre">inv_gaussian_variance2lam()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.isnan"><code class="docutils literal notranslate"><span class="pre">isnan()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.kron"><code class="docutils literal notranslate"><span class="pre">kron()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.kw_np2torch"><code class="docutils literal notranslate"><span class="pre">kw_np2torch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.log_normpdf"><code class="docutils literal notranslate"><span class="pre">log_normpdf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.logistic"><code class="docutils literal notranslate"><span class="pre">logistic()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.logit"><code class="docutils literal notranslate"><span class="pre">logit()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.lognorm_params_given_mean_stdev"><code class="docutils literal notranslate"><span class="pre">lognorm_params_given_mean_stdev()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.lognorm_pmf"><code class="docutils literal notranslate"><span class="pre">lognorm_pmf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.lognormal_params2mean_stdev"><code class="docutils literal notranslate"><span class="pre">lognormal_params2mean_stdev()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.m2v"><code class="docutils literal notranslate"><span class="pre">m2v()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.m2v0"><code class="docutils literal notranslate"><span class="pre">m2v0()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.mat2vec0"><code class="docutils literal notranslate"><span class="pre">mat2vec0()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.matmul0"><code class="docutils literal notranslate"><span class="pre">matmul0()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.matmul2vec"><code class="docutils literal notranslate"><span class="pre">matmul2vec()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.matsum"><code class="docutils literal notranslate"><span class="pre">matsum()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.matvecmul0"><code class="docutils literal notranslate"><span class="pre">matvecmul0()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.max_distrib"><code class="docutils literal notranslate"><span class="pre">max_distrib()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.max_shape"><code class="docutils literal notranslate"><span class="pre">max_shape()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.mean_distrib"><code class="docutils literal notranslate"><span class="pre">mean_distrib()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.min_distrib"><code class="docutils literal notranslate"><span class="pre">min_distrib()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.mm0"><code class="docutils literal notranslate"><span class="pre">mm0()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.mvm0"><code class="docutils literal notranslate"><span class="pre">mvm0()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.mvnpdf_log"><code class="docutils literal notranslate"><span class="pre">mvnpdf_log()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.mvnrnd"><code class="docutils literal notranslate"><span class="pre">mvnrnd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.nan2v"><code class="docutils literal notranslate"><span class="pre">nan2v()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.nanmean"><code class="docutils literal notranslate"><span class="pre">nanmean()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.nansum"><code class="docutils literal notranslate"><span class="pre">nansum()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.normrnd"><code class="docutils literal notranslate"><span class="pre">normrnd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.npy"><code class="docutils literal notranslate"><span class="pre">npy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.npys"><code class="docutils literal notranslate"><span class="pre">npys()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.numpy"><code class="docutils literal notranslate"><span class="pre">numpy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.onehotrnd"><code class="docutils literal notranslate"><span class="pre">onehotrnd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.p2en"><code class="docutils literal notranslate"><span class="pre">p2en()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.p2st"><code class="docutils literal notranslate"><span class="pre">p2st()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.pconc2conc"><code class="docutils literal notranslate"><span class="pre">pconc2conc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.permute2en"><code class="docutils literal notranslate"><span class="pre">permute2en()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.permute2st"><code class="docutils literal notranslate"><span class="pre">permute2st()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.prad2unitvec"><code class="docutils literal notranslate"><span class="pre">prad2unitvec()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.prepend_dim"><code class="docutils literal notranslate"><span class="pre">prepend_dim()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.prepend_to_ndim"><code class="docutils literal notranslate"><span class="pre">prepend_to_ndim()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.rad2deg"><code class="docutils literal notranslate"><span class="pre">rad2deg()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.rand"><code class="docutils literal notranslate"><span class="pre">rand()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.ravel_multi_index"><code class="docutils literal notranslate"><span class="pre">ravel_multi_index()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.repeat_all"><code class="docutils literal notranslate"><span class="pre">repeat_all()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.repeat_batch"><code class="docutils literal notranslate"><span class="pre">repeat_batch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.repeat_dim"><code class="docutils literal notranslate"><span class="pre">repeat_dim()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.repeat_to_shape"><code class="docutils literal notranslate"><span class="pre">repeat_to_shape()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.scatter_add"><code class="docutils literal notranslate"><span class="pre">scatter_add()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.sem"><code class="docutils literal notranslate"><span class="pre">sem()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.sem_distrib"><code class="docutils literal notranslate"><span class="pre">sem_distrib()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.shiftdim"><code class="docutils literal notranslate"><span class="pre">shiftdim()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.softmax_bias"><code class="docutils literal notranslate"><span class="pre">softmax_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.softmax_mask"><code class="docutils literal notranslate"><span class="pre">softmax_mask()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.std_distrib"><code class="docutils literal notranslate"><span class="pre">std_distrib()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.sumto1"><code class="docutils literal notranslate"><span class="pre">sumto1()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.t"><code class="docutils literal notranslate"><span class="pre">t()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.tensor"><code class="docutils literal notranslate"><span class="pre">tensor()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.test_kron"><code class="docutils literal notranslate"><span class="pre">test_kron()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.test_softmax_bias"><code class="docutils literal notranslate"><span class="pre">test_softmax_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.unblock_diag"><code class="docutils literal notranslate"><span class="pre">unblock_diag()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.unravel_index"><code class="docutils literal notranslate"><span class="pre">unravel_index()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.v2m"><code class="docutils literal notranslate"><span class="pre">v2m()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.v2m0"><code class="docutils literal notranslate"><span class="pre">v2m0()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.var_distrib"><code class="docutils literal notranslate"><span class="pre">var_distrib()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.vec2mat0"><code class="docutils literal notranslate"><span class="pre">vec2mat0()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.vec2matmul"><code class="docutils literal notranslate"><span class="pre">vec2matmul()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.vec_on"><code class="docutils literal notranslate"><span class="pre">vec_on()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.vec_on_dim"><code class="docutils literal notranslate"><span class="pre">vec_on_dim()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.vmpdf"><code class="docutils literal notranslate"><span class="pre">vmpdf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.vmpdf_a_given_b"><code class="docutils literal notranslate"><span class="pre">vmpdf_a_given_b()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.external_dependencies.html#meslas.external_dependencies.numpytorch.vmpdf_prad_pconc"><code class="docutils literal notranslate"><span class="pre">vmpdf_prad_pconc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="meslas.external_dependencies.html#module-meslas.external_dependencies">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="meslas.geometry.html">meslas.geometry package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="meslas.geometry.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="meslas.geometry.html#meslas-geometry-grid-module">meslas.geometry.grid module</a></li>
<li class="toctree-l2"><a class="reference internal" href="meslas.geometry.html#module-meslas.geometry.tilings">meslas.geometry.tilings module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="meslas.geometry.html#meslas.geometry.tilings.draw_tiling"><code class="docutils literal notranslate"><span class="pre">draw_tiling()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.geometry.html#meslas.geometry.tilings.generate_hexagons"><code class="docutils literal notranslate"><span class="pre">generate_hexagons()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.geometry.html#meslas.geometry.tilings.generate_squares"><code class="docutils literal notranslate"><span class="pre">generate_squares()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.geometry.html#meslas.geometry.tilings.generate_triangles"><code class="docutils literal notranslate"><span class="pre">generate_triangles()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.geometry.html#meslas.geometry.tilings.generate_unit_hexagons"><code class="docutils literal notranslate"><span class="pre">generate_unit_hexagons()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.geometry.html#meslas.geometry.tilings.generate_unit_squares"><code class="docutils literal notranslate"><span class="pre">generate_unit_squares()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="meslas.geometry.html#meslas.geometry.tilings.generate_unit_triangles"><code class="docutils literal notranslate"><span class="pre">generate_unit_triangles()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="meslas.geometry.html#module-meslas.geometry">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-meslas.excursion">
<span id="meslas-excursion-module"></span><h2>meslas.excursion module<a class="headerlink" href="#module-meslas.excursion" title="Permalink to this heading">¶</a></h2>
<p>Compute coverage function, excursion sets and related quantities.</p>
<dl class="py function">
<dt class="sig sig-object py" id="meslas.excursion.coverage_fct_fixed_location">
<span class="sig-prename descclassname"><span class="pre">meslas.excursion.</span></span><span class="sig-name descname"><span class="pre">coverage_fct_fixed_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mean_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.excursion.coverage_fct_fixed_location" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes coverage function at a fixed set of location.</p>
<p>Ths function should be used when a mean vector and covariance matrix for a
set of locations have been precomputed.</p>
<p>Uses the torch implementation of the multivariate CDF by Sebastien Marmin,
see torch-mvn.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mean_vec: (M, p) Tensor</strong></dt><dd><p>Mean vector at each of the M locations. mean_vec[i, :] should give the
mean vector at location nr i.</p>
</dd>
<dt><strong>cov_mat: (M, p, p) Tensor</strong></dt><dd><p>Covariance matrix at each of the M locations. cov_mat[i, :, :] should
give the covariance matrix at location nr i.</p>
</dd>
<dt><strong>lower: (p) Tensor</strong></dt><dd><p>List of lower threshold for each response. The excursion set is the set
where responses are above the specified threshold.
Note that np.inf is supported. WARNING: wrong shapes can cause
unexpected results.</p>
</dd>
<dt><strong>upper: (p) Tensor</strong></dt><dd><p>List of upper threshold for each response. The excursion set is the set
where responses are above the specified threshold.
If not provided, defaults to + infinity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>excursion_prob: (M) Tensor</dt><dd><p>Probability to be in excursion at each location.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="meslas-inverse-random-fields-module">
<h2>meslas.inverse_random_fields module<a class="headerlink" href="#meslas-inverse-random-fields-module" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-meslas.means">
<span id="meslas-means-module"></span><h2>meslas.means module<a class="headerlink" href="#module-meslas.means" title="Permalink to this heading">¶</a></h2>
<p>Mean functions for GRFs.</p>
<dl class="py class">
<dt class="sig sig-object py" id="meslas.means.ConstantMean">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">meslas.means.</span></span><span class="sig-name descname"><span class="pre">ConstantMean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">means</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.means.ConstantMean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Constant mean function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>means: (p) array-like.</strong></dt><dd><p>Constant mean of each of the p-components.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(S, L)</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="meslas.means.LinearMean">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">meslas.means.</span></span><span class="sig-name descname"><span class="pre">LinearMean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta0s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta1s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.means.LinearMean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Linear trend mean function.
The mean at location x will be given by
beta0 + beta1 x</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>betas0: (p) array-like.</strong></dt><dd><p>Constant mean mean term for of each of the p-components.</p>
</dd>
<dt><strong>betas1: (p, d) array-like.</strong></dt><dd><p>Linear trend matrix for each of the p-components.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(S, L)</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
<section id="meslas-plotting-module">
<h2>meslas.plotting module<a class="headerlink" href="#meslas-plotting-module" title="Permalink to this heading">¶</a></h2>
</section>
<section id="meslas-plotting-physical-module">
<h2>meslas.plotting_physical module<a class="headerlink" href="#meslas-plotting-physical-module" title="Permalink to this heading">¶</a></h2>
</section>
<section id="meslas-random-fields-module">
<h2>meslas.random_fields module<a class="headerlink" href="#meslas-random-fields-module" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-meslas.sensor">
<span id="meslas-sensor-module"></span><h2>meslas.sensor module<a class="headerlink" href="#module-meslas.sensor" title="Permalink to this heading">¶</a></h2>
<p>TODO: Maybe add grid, grf, n_ouptuts to the sensor class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="meslas.sensor.DiscreteSensor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">meslas.sensor.</span></span><span class="sig-name descname"><span class="pre">DiscreteSensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discrete_grf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.DiscreteSensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="sensor.html#meslas.sensor.Sensor" title="meslas.sensor.Sensor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sensor</span></code></a></p>
<p>Sensor on a fixed discretization.</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="sensor.html#meslas.sensor.DiscreteSensor.choose_next_point_myopic" title="meslas.sensor.DiscreteSensor.choose_next_point_myopic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose_next_point_myopic</span></code></a>(noise_std, lower[, ...])</p></td>
<td><p>Choose the next observation location (given the current one) using the myopic strategy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="sensor.html#meslas.sensor.DiscreteSensor.compute_exursion_prob" title="meslas.sensor.DiscreteSensor.compute_exursion_prob"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_exursion_prob</span></code></a>(lower[, upper])</p></td>
<td><p>Compute the excursion probability on the whole grid, given the currently available data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="sensor.html#meslas.sensor.DiscreteSensor.get_neighbors_isotopic_eibv" title="meslas.sensor.DiscreteSensor.get_neighbors_isotopic_eibv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_neighbors_isotopic_eibv</span></code></a>(noise_std, lower)</p></td>
<td><p>For each neighbouring node of the current sensor location, compute the eibv if we were to measure every response (isotopic) at that node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="sensor.html#meslas.sensor.DiscreteSensor.run_lookahead_stragegy" title="meslas.sensor.DiscreteSensor.run_lookahead_stragegy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_lookahead_stragegy</span></code></a>(n_steps, data_feed, ...)</p></td>
<td><p>Run the myopic strategy for n_steps, starting from the current location.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="sensor.html#meslas.sensor.DiscreteSensor.run_myopic_stragegy" title="meslas.sensor.DiscreteSensor.run_myopic_stragegy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_myopic_stragegy</span></code></a>(n_steps, data_feed, ...)</p></td>
<td><p>Run the myopic strategy for n_steps, starting from the current location.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="sensor.html#meslas.sensor.DiscreteSensor.update_design" title="meslas.sensor.DiscreteSensor.update_design"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_design</span></code></a>(S_y_inds, L_y, y[, noise_std])</p></td>
<td><p>Updates the full design grid by computing current conditional mean and covariance.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor.DiscreteSensor.choose_next_point_myopic">
<span class="sig-name descname"><span class="pre">choose_next_point_myopic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise_std</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.DiscreteSensor.choose_next_point_myopic" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose the next observation location (given the current one)
using the myopic strategy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>noise_std: float</strong></dt><dd><p>Standar deviation of measurement noise.</p>
</dd>
<dt><strong>lower: (p) Tensor</strong></dt><dd><p>List of lower threshold for each response. The excursion set is the set
where responses are above the specified threshold.
Note that np.inf is supported.</p>
</dd>
<dt><strong>upper: (p) Tensor</strong></dt><dd><p>If not provided, defaults to +infty (excursion set above
threshold).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>next_point_ind: (1) Tensor</dt><dd><p>Grid index of next observation location chosen according to the
myopic strategy.</p>
</dd>
<dt>next_point_eibv: (1) Tensor</dt><dd><p>EIBV corresponding to the next chosen point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor.DiscreteSensor.compute_exursion_prob">
<span class="sig-name descname"><span class="pre">compute_exursion_prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.DiscreteSensor.compute_exursion_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the excursion probability on the whole grid, given the
currently available data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lower: (p) Tensor</strong></dt><dd><p>List of lower threshold for each response. The excursion set is the set
where responses are above the specified threshold.
Note that np.inf is supported.</p>
</dd>
<dt><strong>upper: (p) Tensor</strong></dt><dd><p>List of upper threshold for each response. The excursion set is the set
where responses are above the specified threshold.
If not provided, defaults to + infinity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>excursion_proba: (self.grid.n_points) Tensor</dt><dd><p>Excursion probability at each point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor.DiscreteSensor.get_neighbors_isotopic_eibv">
<span class="sig-name descname"><span class="pre">get_neighbors_isotopic_eibv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise_std</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.DiscreteSensor.get_neighbors_isotopic_eibv" title="Permalink to this definition">¶</a></dt>
<dd><p>For each neighbouring node of the current sensor location, compute
the eibv if we were to measure every response (isotopic) at that node.
Returns a list containing the EIBV for each neighbor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>noise_std: float</strong></dt><dd><p>Standar deviation of measurement noise.</p>
</dd>
<dt><strong>lower: (p) Tensor</strong></dt><dd><p>List of lower threshold for each response. The excursion set is the set
where responses are above the specified threshold.
Note that np.inf is supported.</p>
</dd>
<dt><strong>upper: (p) Tensor</strong></dt><dd><p>If not provided, defaults to +infty (excursion set above
threshold).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>neighbors_eibv: (n_neighbors) Tensor</dt><dd><p>EIBV for each neighbouring cell.</p>
</dd>
<dt>neighbors_inds: (n_neighbors) Tensor</dt><dd><p>Grid indices of the neighbouring cells.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor.DiscreteSensor.run_lookahead_stragegy">
<span class="sig-name descname"><span class="pre">run_lookahead_stragegy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_feed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_std</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_prune</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.DiscreteSensor.run_lookahead_stragegy" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the myopic strategy for n_steps, starting from the current
location. That is, at each point, pick the neighbors with the smallest
EIBV, move there, observe, update model, repeat.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_steps: int</strong></dt><dd><p>Number of steps (observations) to run the strategy for.</p>
</dd>
<dt><strong>data_feed: function(int)</strong></dt><dd><p>Function that, given a node index, returns the measured data
(isotopic) at that node.</p>
</dd>
<dt><strong>noise_std</strong></dt><dd></dd>
<dt><strong>lower</strong></dt><dd></dd>
<dt><strong>upper</strong></dt><dd></dd>
<dt><strong>n_prune: int</strong></dt><dd><p>Number of paths to consider at the first step. From the starting
node, we will only consider the best n_prune nodes, ranked using
the myopic strategy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor.DiscreteSensor.run_myopic_stragegy">
<span class="sig-name descname"><span class="pre">run_myopic_stragegy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_feed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_std</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.DiscreteSensor.run_myopic_stragegy" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the myopic strategy for n_steps, starting from the current
location. That is, at each point, pick the neighbors with the smallest
EIBV, move there, observe, update model, repeat.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_steps: int</strong></dt><dd><p>Number of steps (observations) to run the strategy for.</p>
</dd>
<dt><strong>data_feed: function(int)</strong></dt><dd><p>Function that, given a node index, returns the measured data
(isotopic) at that node.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor.DiscreteSensor.update_design">
<span class="sig-name descname"><span class="pre">update_design</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S_y_inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.DiscreteSensor.update_design" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the full design grid by computing current conditional mean and covariance.
Note that this updates the internal of the discrete GRF.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>mu_cond_iso: (self.grid.n_points, self.grf.n_out)</dt><dd><p>Conditional mean.</p>
</dd>
<dt>K_cond_iso: (self.grid.n_points, self.grid.n_points, self.grf.n_out, self.grf.n_out) Tensor</dt><dd><p>Conditional covariance matrix in isotopic ordered form.
It means that the covariance matrix at cell i can be otained by
subsetting K_cond_iso[i, i, :, :].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="meslas.sensor.Sensor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">meslas.sensor.</span></span><span class="sig-name descname"><span class="pre">Sensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.Sensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Implements the data collection process.
Will be responsible for querying the GP for mean and variances conditional
on the already collected data.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S_y_tot: (N, d) Tensor</strong></dt><dd><p>Spatial locations of the already collected data.</p>
</dd>
<dt><strong>L_y_tot: (N) Tensor</strong></dt><dd><p>Corresponding response indices.</p>
</dd>
<dt><strong>location: (d) Tensor</strong></dt><dd><p>Current position of the sensor.</p>
</dd>
<dt><strong>grid: IrregularGrid</strong></dt><dd><p>A discretization of space that defines the locations the sensor can
move to.</p>
</dd>
<dt><strong>grf: GRF</strong></dt><dd><p>Gaussian Random Field used to model the unknown phenomenon of interest.</p>
</dd>
<dt><strong>current_node_ind: int</strong></dt><dd><p>Index of the point in the grid that is closest to the sensor location.</p>
</dd>
<dt><strong>visited_nodes_inds: Tensor</strong></dt><dd><p>Grid indices of the visited locations.</p>
</dd>
<dt><strong>noise_std: float</strong></dt><dd><p>Standard deviation of the sensor noise.
TODO: allow different noises for each component.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="sensor.html#meslas.sensor.Sensor.add_data" title="meslas.sensor.Sensor.add_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_data</span></code></a>(S_y_inds, L_y, y)</p></td>
<td><p>Add new data to the already collected one.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="sensor.html#meslas.sensor.Sensor.compute_exursion_prob" title="meslas.sensor.Sensor.compute_exursion_prob"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_exursion_prob</span></code></a>(points, lower[, upper])</p></td>
<td><p>Compute the excursion probability at a set of points given the currently available data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="sensor.html#meslas.sensor.Sensor.compute_neighbors_exursion_prob" title="meslas.sensor.Sensor.compute_neighbors_exursion_prob"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_neighbors_exursion_prob</span></code></a>(lower[, upper])</p></td>
<td><p>Compute the excursion probability of the neighbors of the current location.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="sensor.html#meslas.sensor.Sensor.get_current_neighbors" title="meslas.sensor.Sensor.get_current_neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_current_neighbors</span></code></a>()</p></td>
<td><p>Get the neighbouring grid nodes of the current sensor location.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="sensor.html#meslas.sensor.Sensor.set_location" title="meslas.sensor.Sensor.set_location"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_location</span></code></a>(location)</p></td>
<td><p>Setter for the location.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor.Sensor.add_data">
<span class="sig-name descname"><span class="pre">add_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S_y_inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.Sensor.add_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new data to the already collected one.
Can also handle batches.
This will just concatenate the new data vectors with the current ones.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S_y_inds: (n) Tensor</strong></dt><dd><p>Grind index of spatial locations of the new measurements.</p>
</dd>
<dt><strong>L_y :(n) Tensor</strong></dt><dd><p>Corresponding response indices.</p>
</dd>
<dt><strong>y :(n, p) Tensor</strong></dt><dd><p>Measured data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor.Sensor.compute_exursion_prob">
<span class="sig-name descname"><span class="pre">compute_exursion_prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.Sensor.compute_exursion_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the excursion probability at a set of points given the
currently available data.</p>
<p>Note this is a helper function that take an index in the grid as input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points: (N, d) Tensor</strong></dt><dd><p>List of points (coordinates) at which to compute the excursion probability.</p>
</dd>
<dt><strong>lower: (p) Tensor</strong></dt><dd><p>List of lower threshold for each response. The excursion set is the set
where responses are above the specified threshold.
Note that np.inf is supported.</p>
</dd>
<dt><strong>upper: (p) Tensor</strong></dt><dd><p>List of upper threshold for each response. The excursion set is the set
where responses are above the specified threshold.
If not provided, defaults to + infinity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>excursion_proba: (N) Tensor</dt><dd><p>Excursion probability at each point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor.Sensor.compute_neighbors_exursion_prob">
<span class="sig-name descname"><span class="pre">compute_neighbors_exursion_prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.Sensor.compute_neighbors_exursion_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the excursion probability of the neighbors of the current
location.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lower: (p) Tensor</strong></dt><dd><p>List of lower threshold for each response. The excursion set is the set
where responses are above the specified threshold.
Note that np.inf is supported.</p>
</dd>
<dt><strong>upper: (p) Tensor</strong></dt><dd><p>List of upper threshold for each response. The excursion set is the set
where responses are above the specified threshold.
If not provided, defaults to + infinity.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor.Sensor.get_current_neighbors">
<span class="sig-name descname"><span class="pre">get_current_neighbors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.Sensor.get_current_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the neighbouring grid nodes of the current sensor location.</p>
<p>This is done by first finding the node closes to the sensor location,
and then returning its neighbors.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>neighbors_inds: (n_neighbors)</dt><dd><p>Grid indices of the neighbors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor.Sensor.set_location">
<span class="sig-name descname"><span class="pre">set_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">location</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor.Sensor.set_location" title="Permalink to this definition">¶</a></dt>
<dd><p>Setter for the location.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>location: (d) array_like</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-meslas.sensor_plotting">
<span id="meslas-sensor-plotting-module"></span><h2>meslas.sensor_plotting module<a class="headerlink" href="#module-meslas.sensor_plotting" title="Permalink to this heading">¶</a></h2>
<p>REPORTING VERSION OF THE SENSOR MODULE.</p>
<p>The problem is that at stage n, we havent yet computed the ebiv of the
neighbors and if we want a sensible plot, we have to provide the eibvs with the
CURRENT status of the model.
This doesn’t agree with the natural flow of the myopic search, so we choose to
have a dedicated version of the module to produce the plots.</p>
<dl class="py class">
<dt class="sig sig-object py" id="meslas.sensor_plotting.DiscreteSensor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">meslas.sensor_plotting.</span></span><span class="sig-name descname"><span class="pre">DiscreteSensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discrete_grf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor_plotting.DiscreteSensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#meslas.sensor_plotting.Sensor" title="meslas.sensor_plotting.Sensor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sensor</span></code></a></p>
<p>Sensor on a fixed discretization.</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#meslas.sensor_plotting.DiscreteSensor.choose_next_point_myopic" title="meslas.sensor_plotting.DiscreteSensor.choose_next_point_myopic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose_next_point_myopic</span></code></a>(noise_std, lower[, ...])</p></td>
<td><p>Choose the next observation location (given the current one) using the myopic strategy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#meslas.sensor_plotting.DiscreteSensor.compute_exursion_prob" title="meslas.sensor_plotting.DiscreteSensor.compute_exursion_prob"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_exursion_prob</span></code></a>(lower[, upper])</p></td>
<td><p>Compute the excursion probability on the whole grid, given the currently available data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#meslas.sensor_plotting.DiscreteSensor.get_neighbors_isotopic_eibv" title="meslas.sensor_plotting.DiscreteSensor.get_neighbors_isotopic_eibv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_neighbors_isotopic_eibv</span></code></a>(noise_std, lower)</p></td>
<td><p>For each neighbouring node of the current sensor location, compute the eibv if we were to measure every response (isotopic) at that node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#meslas.sensor_plotting.DiscreteSensor.run_myopic_stragegy" title="meslas.sensor_plotting.DiscreteSensor.run_myopic_stragegy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_myopic_stragegy</span></code></a>(n_steps, data_feed, ...)</p></td>
<td><p>Run the myopic strategy for n_steps, starting from the current location.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#meslas.sensor_plotting.DiscreteSensor.update_design" title="meslas.sensor_plotting.DiscreteSensor.update_design"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_design</span></code></a>(S_y_inds, L_y, y[, noise_std])</p></td>
<td><p>Updates the full design grid by computing current conditional mean and covariance.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor_plotting.DiscreteSensor.choose_next_point_myopic">
<span class="sig-name descname"><span class="pre">choose_next_point_myopic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise_std</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor_plotting.DiscreteSensor.choose_next_point_myopic" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose the next observation location (given the current one)
using the myopic strategy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>noise_std: float</strong></dt><dd><p>Standar deviation of measurement noise.</p>
</dd>
<dt><strong>lower: (p) Tensor</strong></dt><dd><p>List of lower threshold for each response. The excursion set is the set
where responses are above the specified threshold.
Note that np.inf is supported.</p>
</dd>
<dt><strong>upper: (p) Tensor</strong></dt><dd><p>If not provided, defaults to +infty (excursion set above
threshold).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>next_point_ind: (1) Tensor</dt><dd><p>Grid index of next observation location chosen according to the
myopic strategy.</p>
</dd>
<dt>next_point_eibv: (1) Tensor</dt><dd><p>EIBV corresponding to the next chosen point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor_plotting.DiscreteSensor.compute_exursion_prob">
<span class="sig-name descname"><span class="pre">compute_exursion_prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor_plotting.DiscreteSensor.compute_exursion_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the excursion probability on the whole grid, given the
currently available data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lower: (p) Tensor</strong></dt><dd><p>List of lower threshold for each response. The excursion set is the set
where responses are above the specified threshold.
Note that np.inf is supported.</p>
</dd>
<dt><strong>upper: (p) Tensor</strong></dt><dd><p>List of upper threshold for each response. The excursion set is the set
where responses are above the specified threshold.
If not provided, defaults to + infinity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>excursion_proba: (self.grid.n_points) Tensor</dt><dd><p>Excursion probability at each point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor_plotting.DiscreteSensor.get_neighbors_isotopic_eibv">
<span class="sig-name descname"><span class="pre">get_neighbors_isotopic_eibv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise_std</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor_plotting.DiscreteSensor.get_neighbors_isotopic_eibv" title="Permalink to this definition">¶</a></dt>
<dd><p>For each neighbouring node of the current sensor location, compute
the eibv if we were to measure every response (isotopic) at that node.
Returns a list containing the EIBV for each neighbor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>noise_std: float</strong></dt><dd><p>Standar deviation of measurement noise.</p>
</dd>
<dt><strong>lower: (p) Tensor</strong></dt><dd><p>List of lower threshold for each response. The excursion set is the set
where responses are above the specified threshold.
Note that np.inf is supported.</p>
</dd>
<dt><strong>upper: (p) Tensor</strong></dt><dd><p>If not provided, defaults to +infty (excursion set above
threshold).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>neighbors_eibv: (n_neighbors) Tensor</dt><dd><p>EIBV for each neighbouring cell.</p>
</dd>
<dt>neighbors_inds: (n_neighbors) Tensor</dt><dd><p>Grid indices of the neighbouring cells.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor_plotting.DiscreteSensor.run_myopic_stragegy">
<span class="sig-name descname"><span class="pre">run_myopic_stragegy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_feed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_std</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor_plotting.DiscreteSensor.run_myopic_stragegy" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the myopic strategy for n_steps, starting from the current
location. That is, at each point, pick the neighbors with the smallest
EIBV, move there, observe, update model, repeat.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_steps: int</strong></dt><dd><p>Number of steps (observations) to run the strategy for.</p>
</dd>
<dt><strong>data_feed: function(int)</strong></dt><dd><p>Function that, given a node index, returns the measured data
(isotopic) at that node.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor_plotting.DiscreteSensor.update_design">
<span class="sig-name descname"><span class="pre">update_design</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S_y_inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor_plotting.DiscreteSensor.update_design" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the full design grid by computing current conditional mean and covariance.
Note that this updates the internal of the discrete GRF.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>mu_cond_iso: (self.grid.n_points, self.grf.n_out)</dt><dd><p>Conditional mean.</p>
</dd>
<dt>K_cond_iso: (self.grid.n_points, self.grid.n_points, self.grf.n_out, self.grf.n_out) Tensor</dt><dd><p>Conditional covariance matrix in isotopic ordered form.
It means that the covariance matrix at cell i can be otained by
subsetting K_cond_iso[i, i, :, :].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="meslas.sensor_plotting.Sensor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">meslas.sensor_plotting.</span></span><span class="sig-name descname"><span class="pre">Sensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor_plotting.Sensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Implements the data collection process.
Will be responsible for querying the GP for mean and variances conditional
on the already collected data.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S_y_tot: (N, d) Tensor</strong></dt><dd><p>Spatial locations of the already collected data.</p>
</dd>
<dt><strong>L_y_tot: (N) Tensor</strong></dt><dd><p>Corresponding response indices.</p>
</dd>
<dt><strong>location: (d) Tensor</strong></dt><dd><p>Current position of the sensor.</p>
</dd>
<dt><strong>grid: IrregularGrid</strong></dt><dd><p>A discretization of space that defines the locations the sensor can
move to.</p>
</dd>
<dt><strong>grf: GRF</strong></dt><dd><p>Gaussian Random Field used to model the unknown phenomenon of interest.</p>
</dd>
<dt><strong>current_node_ind: int</strong></dt><dd><p>Index of the point in the grid that is closest to the sensor location.</p>
</dd>
<dt><strong>visited_nodes_inds: Tensor</strong></dt><dd><p>Grid indices of the visited locations.</p>
</dd>
<dt><strong>noise_std: float</strong></dt><dd><p>Standard deviation of the sensor noise.
TODO: allow different noises for each component.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#meslas.sensor_plotting.Sensor.add_data" title="meslas.sensor_plotting.Sensor.add_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_data</span></code></a>(S_y_inds, L_y, y)</p></td>
<td><p>Add new data to the already collected one.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#meslas.sensor_plotting.Sensor.compute_exursion_prob" title="meslas.sensor_plotting.Sensor.compute_exursion_prob"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_exursion_prob</span></code></a>(points, lower[, upper])</p></td>
<td><p>Compute the excursion probability at a set of points given the currently available data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#meslas.sensor_plotting.Sensor.compute_neighbors_exursion_prob" title="meslas.sensor_plotting.Sensor.compute_neighbors_exursion_prob"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_neighbors_exursion_prob</span></code></a>(lower[, upper])</p></td>
<td><p>Compute the excursion probability of the neighbors of the current location.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#meslas.sensor_plotting.Sensor.get_current_neighbors" title="meslas.sensor_plotting.Sensor.get_current_neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_current_neighbors</span></code></a>()</p></td>
<td><p>Get the neighbouring grid nodes of the current sensor location.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#meslas.sensor_plotting.Sensor.set_location" title="meslas.sensor_plotting.Sensor.set_location"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_location</span></code></a>(location)</p></td>
<td><p>Setter for the location.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor_plotting.Sensor.add_data">
<span class="sig-name descname"><span class="pre">add_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S_y_inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor_plotting.Sensor.add_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new data to the already collected one.
Can also handle batches.
This will just concatenate the new data vectors with the current ones.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>S_y_inds: (n) Tensor</strong></dt><dd><p>Grind index of spatial locations of the new measurements.</p>
</dd>
<dt><strong>L_y :(n) Tensor</strong></dt><dd><p>Corresponding response indices.</p>
</dd>
<dt><strong>y :(n, p) Tensor</strong></dt><dd><p>Measured data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor_plotting.Sensor.compute_exursion_prob">
<span class="sig-name descname"><span class="pre">compute_exursion_prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor_plotting.Sensor.compute_exursion_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the excursion probability at a set of points given the
currently available data.</p>
<p>Note this is a helper function that take an index in the grid as input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points: (N, d) Tensor</strong></dt><dd><p>List of points (coordinates) at which to compute the excursion probability.</p>
</dd>
<dt><strong>lower: (p) Tensor</strong></dt><dd><p>List of lower threshold for each response. The excursion set is the set
where responses are above the specified threshold.
Note that np.inf is supported.</p>
</dd>
<dt><strong>upper: (p) Tensor</strong></dt><dd><p>List of upper threshold for each response. The excursion set is the set
where responses are above the specified threshold.
If not provided, defaults to + infinity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>excursion_proba: (N) Tensor</dt><dd><p>Excursion probability at each point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor_plotting.Sensor.compute_neighbors_exursion_prob">
<span class="sig-name descname"><span class="pre">compute_neighbors_exursion_prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor_plotting.Sensor.compute_neighbors_exursion_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the excursion probability of the neighbors of the current
location.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lower: (p) Tensor</strong></dt><dd><p>List of lower threshold for each response. The excursion set is the set
where responses are above the specified threshold.
Note that np.inf is supported.</p>
</dd>
<dt><strong>upper: (p) Tensor</strong></dt><dd><p>List of upper threshold for each response. The excursion set is the set
where responses are above the specified threshold.
If not provided, defaults to + infinity.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor_plotting.Sensor.get_current_neighbors">
<span class="sig-name descname"><span class="pre">get_current_neighbors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor_plotting.Sensor.get_current_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the neighbouring grid nodes of the current sensor location.</p>
<p>This is done by first finding the node closes to the sensor location,
and then returning its neighbors.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>neighbors_inds: (n_neighbors)</dt><dd><p>Grid indices of the neighbors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.sensor_plotting.Sensor.set_location">
<span class="sig-name descname"><span class="pre">set_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">location</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.sensor_plotting.Sensor.set_location" title="Permalink to this definition">¶</a></dt>
<dd><p>Setter for the location.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>location: (d) array_like</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-meslas.vectors">
<span id="meslas-vectors-module"></span><h2>meslas.vectors module<a class="headerlink" href="#module-meslas.vectors" title="Permalink to this heading">¶</a></h2>
<p>Encapsulation of the reshaping between isotopic and non-isotopic form.</p>
<dl class="py class">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedMatrix">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">meslas.vectors.</span></span><span class="sig-name descname"><span class="pre">GeneralizedMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_points1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_out1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_points2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_out2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.vectors.GeneralizedMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Same as GeneralizedVector, but for matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#meslas.vectors.GeneralizedMatrix.isotopic" title="meslas.vectors.GeneralizedMatrix.isotopic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isotopic</span></code></a></dt><dd><p>Returns the 2D isotopic form of the generalized vector.</p>
</dd>
<dt><a class="reference internal" href="#meslas.vectors.GeneralizedMatrix.list" title="meslas.vectors.GeneralizedMatrix.list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code></a></dt><dd><p>Returns the 1D list form of the generalized vector.</p>
</dd>
<dt><strong>shape</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#meslas.vectors.GeneralizedMatrix.numpy" title="meslas.vectors.GeneralizedMatrix.numpy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a>()</p></td>
<td><p>Returns a numpy array containing the isotopic form of the matrix.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>from_isotopic</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>from_list</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>set_vals</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedMatrix.from_isotopic">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_isotopic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vals_iso</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.vectors.GeneralizedMatrix.from_isotopic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedMatrix.from_list">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_points1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_out1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_points2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_out2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.vectors.GeneralizedMatrix.from_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedMatrix.isotopic">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">isotopic</span></span><a class="headerlink" href="#meslas.vectors.GeneralizedMatrix.isotopic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 2D isotopic form of the generalized vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>vals_isotopic: (self.n_points, self.n_out) Tensor</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedMatrix.list">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">list</span></span><a class="headerlink" href="#meslas.vectors.GeneralizedMatrix.list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 1D list form of the generalized vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>vals_list: (self.n_points * self.n_out) Tensor</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedMatrix.numpy">
<span class="sig-name descname"><span class="pre">numpy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#meslas.vectors.GeneralizedMatrix.numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a numpy array containing the isotopic form of the matrix.
Used for interfacing with others libraries and for saving.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedMatrix.set_vals">
<span class="sig-name descname"><span class="pre">set_vals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.vectors.GeneralizedMatrix.set_vals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedMatrix.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#meslas.vectors.GeneralizedMatrix.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedVector">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">meslas.vectors.</span></span><span class="sig-name descname"><span class="pre">GeneralizedVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.vectors.GeneralizedVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A generalized vector is used to implement the types of vectors that
appear when working with multivariate random fields. Given <em>n_points</em>
points in space, the value of a <em>n_out</em> dimensional random process at those
points may be represented as a (n_points, n_out) vector. But for some
operations (like sampling) it makes sense to expand this as a one
dimensional vector of lenght (n_points, n_out). This is what this class is
used for.</p>
<p>The two dimensional form is called the <em>isotopic</em> form, by analogy with the
process of measuring all components of a random field, whereas the
one-dimensional form is called the list form.</p>
<p>The underlying data structure is always a one-dimensional list of values.
The class is indexable as GeneralizedVector[…], and the indexing will be
performed on the isotopic from. What will be returned is a subset of the
isotopic tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#meslas.vectors.GeneralizedVector.isotopic" title="meslas.vectors.GeneralizedVector.isotopic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isotopic</span></code></a></dt><dd><p>Returns the 2D isotopic form of the generalized vector.</p>
</dd>
<dt><a class="reference internal" href="#meslas.vectors.GeneralizedVector.list" title="meslas.vectors.GeneralizedVector.list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code></a></dt><dd><p>Returns the 1D list form of the generalized vector.</p>
</dd>
<dt><strong>shape</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#meslas.vectors.GeneralizedVector.numpy" title="meslas.vectors.GeneralizedVector.numpy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a>()</p></td>
<td><p>Returns a numpy array containing the isotopic form of the vector.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>from_isotopic</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>from_list</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>set_vals</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedVector.from_isotopic">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_isotopic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vals_iso</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.vectors.GeneralizedVector.from_isotopic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedVector.from_list">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.vectors.GeneralizedVector.from_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedVector.isotopic">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">isotopic</span></span><a class="headerlink" href="#meslas.vectors.GeneralizedVector.isotopic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 2D isotopic form of the generalized vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>vals_isotopic: (self.n_points, self.n_out) Tensor</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedVector.list">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">list</span></span><a class="headerlink" href="#meslas.vectors.GeneralizedVector.list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 1D list form of the generalized vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>vals_list: (self.n_points * self.n_out) Tensor</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedVector.numpy">
<span class="sig-name descname"><span class="pre">numpy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#meslas.vectors.GeneralizedVector.numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a numpy array containing the isotopic form of the vector.
Used for interfacing with others libraries and for saving.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedVector.set_vals">
<span class="sig-name descname"><span class="pre">set_vals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#meslas.vectors.GeneralizedVector.set_vals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="meslas.vectors.GeneralizedVector.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#meslas.vectors.GeneralizedVector.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-meslas">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-meslas" title="Permalink to this heading">¶</a></h2>
</section>
</section>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, Trygve Olav Fossum, Jo Eidsvik, David Ginsbourger, Cedric Travelletti.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>